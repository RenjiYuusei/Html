<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Text</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const cn = (...classes) => classes.filter(Boolean).join(' ');

        function Blinker() {
            const [show, setShow] = React.useState(true);
            React.useEffect(() => {
                const interval = setInterval(() => {
                    setShow(prev => !prev);
                }, 500);
                return () => clearInterval(interval);
            }, []);
            return <span className={show ? "" : "opacity-0"}>|</span>;
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function SmoothEffect({ words, index, alwaysVisibleCount }) {
            return (
                <div className="flex flex-wrap whitespace-pre">
                    {words.map((word, wordIndex) => (
                        <span
                            key={wordIndex}
                            className={cn("transition-opacity duration-300 ease-in-out", {
                                "opacity-100": wordIndex < index,
                                "opacity-0": wordIndex >= index + alwaysVisibleCount,
                            })}
                        >
                            {word.split('').map((char, charIndex) => (
                                <span key={charIndex} style={{ color: getRandomColor() }}>{char}</span>
                            ))}
                            {wordIndex < words.length && <span>Â </span>}
                        </span>
                    ))}
                </div>
            );
        }

        function NormalEffect({ text, index, alwaysVisibleCount }) {
            return (
                <>
                    {text.slice(0, Math.max(index, Math.min(text.length, alwaysVisibleCount ?? 1))).split('').map((char, charIndex) => (
                        <span key={charIndex} style={{ color: getRandomColor() }}>{char}</span>
                    ))}
                </>
            );
        }

        const TypingDirection = {
            Forward: 1,
            Backward: -1,
        };

        function CursorWrapper({ visible, children, waiting }) {
            const [on, setOn] = React.useState(true);
            React.useEffect(() => {
                const interval = setInterval(() => {
                    setOn(prev => !prev);
                }, 100);
                return () => clearInterval(interval);
            }, []);

            if (!visible || (!on && !waiting)) {
                return null;
            }

            return children;
        }

        function Type({
            text,
            repeat,
            cursor,
            delay,
            grow,
            className,
            alwaysVisibleCount,
            smooth,
            waitTime = 1000,
            onComplete,
            hideCursorOnComplete,
        }) {
            const [index, setIndex] = React.useState(0);
            const [direction, setDirection] = React.useState(TypingDirection.Forward);
            const [isComplete, setIsComplete] = React.useState(false);

            const words = React.useMemo(() => text.split(/\s+/), [text]);
            const total = smooth ? words.length : text.length;

            React.useEffect(() => {
                let interval;

                const startTyping = () => {
                    setIndex(prevDir => {
                        if (direction === TypingDirection.Backward && prevDir === 0) {
                            clearInterval(interval);
                        } else if (direction === TypingDirection.Forward && prevDir === total -1) {
                            clearInterval(interval);
                        }
                        return prevDir + direction;
                    });
                };

                interval = setInterval(startTyping, delay);
                return () => clearInterval(interval);
            }, [total, direction, delay]);

            React.useEffect(() => {
                let timeout;

                if (index >= total && repeat) {
                    timeout = setTimeout(() => {
                        setDirection(-1);
                    }, waitTime);
                }

                if (index <= 0 && repeat) {
                    timeout = setTimeout(() => {
                        setDirection(1);
                    }, waitTime);
                }
                return () => clearTimeout(timeout);
            }, [index, total, repeat, waitTime]);

            React.useEffect(() => {
                if (index === total && !repeat) {
                    setIsComplete(true);
                    onComplete?.();
                }
            }, [index, total, repeat, onComplete]);

            const waitingNextCycle = index === total || index === 0;

            return (
                <div className={cn("relative font-mono", className)}>
                    {!grow && <div className="invisible">{text}</div>}
                    <div
                        className={cn({
                            "absolute inset-0 h-full w-full": !grow,
                        })}
                    >
                        {smooth ? (
                            <SmoothEffect words={words} index={index} alwaysVisibleCount={alwaysVisibleCount ?? 1} />
                        ) : (
                            <NormalEffect text={text} index={index} alwaysVisibleCount={alwaysVisibleCount ?? 1} />
                        )}
                        <CursorWrapper
                            waiting={waitingNextCycle}
                            visible={Boolean(!smooth && cursor && (!hideCursorOnComplete || !isComplete))}
                        >
                            {cursor}
                        </CursorWrapper>
                    </div>
                </div>
            );
        }

        function TypingText({
            text,
            repeat = true,
            cursor = <Blinker />,
            delay = 32,
            className,
            grow = false,
            alwaysVisibleCount = 1,
            smooth = false,
            waitTime,
            onComplete,
            hideCursorOnComplete = false,
        }) {
            return (
                <Type
                    key={text}
                    delay={delay ?? 32}
                    waitTime={waitTime ?? 1000}
                    grow={grow}
                    repeat={repeat}
                    text={text}
                    cursor={cursor}
                    className={className}
                    smooth={smooth}
                    alwaysVisibleCount={alwaysVisibleCount}
                    onComplete={onComplete}
                    hideCursorOnComplete={hideCursorOnComplete}
                />
            );
        }


        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TypingText text="Hello, world! This is a typing effect.  It's pretty cool!" />);
    </script>
</body>
</html>
